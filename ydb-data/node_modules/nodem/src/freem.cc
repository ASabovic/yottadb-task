/*
 * Package:    NodeM
 * File:       freem.cc
 * Summary:    Functions that wrap calls to the FreeM API
 * Maintainer: David Wicksell <dlw@linux.com>
 *
 * Written by David Wicksell <dlw@linux.com>
 * Copyright Â© 2018-2022 Fourth Watch Software LC
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (AGPL) as published
 * by the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 */

#include "freem.h"

using std::cerr;
using std::string;

namespace freem {

// ***Begin Public APIs***

/*
 * @function freem::data
 * @summary Check if global or local node has data and/or children or not
 * @param {NodemBaton*} nodem_baton - struct containing the following members
 * @member {string} name - Global or local variable name
 * @member {vector<string>} subs_array - Subscripts
 * @member {char*} result - Data returned from FreeM
 * @member {char*} error - Error message returned from FreeM
 * @member {NodemState*} nodem_state - Per-thread state class containing the following members
 * @nested-member {debug_t} debug - Debug mode: OFF, LOW, MEDIUM, or HIGH; defaults to OFF
 * @returns {int} status - Return code; 0 is success, any other number is an error code
 */
int data(nodem::NodemBaton* nodem_baton)
{
    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::data enter");

    if (nodem_baton->nodem_state->debug > nodem::MEDIUM) {
        nodem::debug_log(">>>    name: ", nodem_baton->name);

        if (nodem_baton->subs_array.size()) {
            for (unsigned int i = 0; i < nodem_baton->subs_array.size(); i++) {
                nodem::debug_log(">>   subscripts[", i, "]: ", nodem_baton->subs_array[i]);
            }
        }
    }

    freem_ref_t glvn;
    char* var_name = (char*) nodem_baton->name.c_str();

    if (nodem_baton->name.compare(0, 2, "^$") == 0) {
        glvn.reftype = MREF_RT_SSVN;
        var_name = &var_name[2];
    } else if (nodem_baton->name.compare(0, 1, "^") == 0) {
        glvn.reftype = MREF_RT_GLOBAL;
        var_name = &var_name[1];
    } else {
        glvn.reftype = MREF_RT_LOCAL;
    }

    strncpy(glvn.name, var_name, 255);
    glvn.subscript_count = nodem_baton->subs_array.size();

    for (unsigned int i = 0; i < glvn.subscript_count; i++) strncpy(glvn.subscripts[i], nodem_baton->subs_array[i].c_str(), 255);

    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   call using FreeM API");
    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);

    int status = freem_data(&glvn);

    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);

    strncpy(nodem_baton->result, glvn.value, STRLEN);

    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::data exit");

    return status;
} // @end freem::data function

/*
 * @function freem::get
 * @summary Get data from a global or local node, or an intrinsic special variable
 * @param {NodemBaton*} nodem_baton - struct containing the following members
 * @member {string} name - Global, local, or intrinsic special variable name
 * @member {vector<string>} subs_array - Subscripts
 * @member {char*} result - Data returned from FreeM
 * @member {char*} error - Error message returned from FreeM
 * @member {NodemState*} nodem_state - Per-thread state class containing the following members
 * @nested-member {debug_t} debug - Debug mode: OFF, LOW, MEDIUM, or HIGH; defaults to OFF
 * @returns {int} status - Return code; 0 is success, any other number is an error code
 */
int get(nodem::NodemBaton* nodem_baton)
{
    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::get enter");

    if (nodem_baton->nodem_state->debug > nodem::MEDIUM) {
        nodem::debug_log(">>>    name: ", nodem_baton->name);

        if (nodem_baton->subs_array.size()) {
            for (unsigned int i = 0; i < nodem_baton->subs_array.size(); i++) {
                nodem::debug_log(">>   subscripts[", i, "]: ", nodem_baton->subs_array[i]);
            }
        }
    }

    freem_ref_t glvn;
    char* var_name = (char*) nodem_baton->name.c_str();

    if (nodem_baton->name.compare(0, 2, "^$") == 0) {
        glvn.reftype = MREF_RT_SSVN;
        var_name = &var_name[2];
    } else if (nodem_baton->name.compare(0, 1, "^") == 0) {
        glvn.reftype = MREF_RT_GLOBAL;
        var_name = &var_name[1];
    } else {
        glvn.reftype = MREF_RT_LOCAL;
    }

    strncpy(glvn.name, var_name, 255);
    glvn.subscript_count = nodem_baton->subs_array.size();

    for (unsigned int i = 0; i < glvn.subscript_count; i++) strncpy(glvn.subscripts[i], nodem_baton->subs_array[i].c_str(), 255);

    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   call using FreeM API");
    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);

    int status = freem_get(&glvn);

    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);

    strncpy(nodem_baton->result, glvn.value, STRLEN);

    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::get exit");

    return status;
} // @end freem::get function

///*
// * @function freem::set
// * @summary Set a global or local node, or an intrinsic special variable
// * @param {NodemBaton*} nodem_baton - struct containing the following members
// * @member {string} name - Global, local, or intrinsic special variable name
// * @member {vector<string>} subs_array - Subscripts
// * @member {string} value - Value to set
// * @member {char*} error - Error message returned from YottaDB, via the SimpleAPI interface
// * @member {NodemState*} nodem_state - Per-thread state class containing the following members
// * @nested-member {debug_t} debug - Debug mode: OFF, LOW, MEDIUM, or HIGH; defaults to OFF
// * @returns {int} status - Return code; 0 is success, any other number is an error code
// */
//int set(nodem::NodemBaton* nodem_baton)
//{
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::set enter");
//
//    if (nodem_baton->nodem_state->debug > nodem::MEDIUM) {
//        nodem::debug_log(">>>    name: ", nodem_baton->name);
//        nodem::debug_log(">>>    value: ", nodem_baton->value);
//
//        if (nodem_baton->subs_array.size()) {
//            for (unsigned int i = 0; i < nodem_baton->subs_array.size(); i++) {
//                nodem::debug_log(">>   subscripts[", i, "]: ", nodem_baton->subs_array[i]);
//            }
//        }
//    }
//
//    /*
//    string save_result;
//    bool change_isv = false;
//
//    if (nodem_baton->name.compare(0, 2, "^[") == 0 || nodem_baton->name.compare(0, 2, "^|") == 0) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    char* var_name = (char*) nodem_baton->name.c_str();
//
//    ydb_buffer_t glvn;
//    glvn.len_alloc = glvn.len_used = strlen(var_name);
//    glvn.buf_addr = var_name;
//
//    ydb_buffer_t subs_array[YDB_MAX_SUBS];
//    unsigned int subs_size = nodem_baton->subs_array.size();
//
//    for (unsigned int i = 0; i < subs_size; i++) {
//        subs_array[i].len_alloc = subs_array[i].len_used = nodem_baton->subs_array[i].length();
//        subs_array[i].buf_addr = (char*) nodem_baton->subs_array[i].c_str();
//    }
//
//    char* value = (char*) nodem_baton->value.c_str();
//
//    ydb_buffer_t data_node;
//    data_node.len_alloc = data_node.len_used = strlen(value);
//    data_node.buf_addr = value;
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   call using SimpleAPI");
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//    int status = freem_set(&glvn, subs_size, subs_array, &data_node);
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//    if (status != YDB_OK) ydb_zstatus(nodem_baton->error, ERR_LEN);
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//
//    /*
//    if (change_isv) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::set exit");
//
//    return status;
//} // @end freem::set
//
///*
// * @function freem::kill
// * @summary Kill a global or global node, or a local or local node, or the entire local symbol table
// * @param {NodemBaton*} nodem_baton - struct containing the following members
// * @member {string} name - Global or local variable name
// * @member {vector<string>} subs_array - Subscripts
// * @member {int32_t} node_only (-1|<0>|1) - Whether to kill only the node, or also kill child subscripts; 0 is children, 1 node-only
// * @member {char*} error - Error message returned from YottaDB, via the SimpleAPI interface
// * @member {NodemState*} nodem_state - Per-thread state class containing the following members
// * @nested-member {debug_t} debug - Debug mode: OFF, LOW, MEDIUM, or HIGH; defaults to OFF
// * @returns {int} status - Return code; 0 is success, any other number is an error code
// */
//int kill(nodem::NodemBaton* nodem_baton)
//{
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::kill enter");
//
//    if (nodem_baton->nodem_state->debug > nodem::MEDIUM) {
//        nodem::debug_log(">>>    name: ", nodem_baton->name);
//        nodem::debug_log(">>>    node_only: ", nodem_baton->node_only);
//
//        if (nodem_baton->subs_array.size()) {
//            for (unsigned int i = 0; i < nodem_baton->subs_array.size(); i++) {
//                nodem::debug_log(">>   subscripts[", i, "]: ", nodem_baton->subs_array[i]);
//            }
//        }
//    }
//
//    /*
//    string save_result;
//    bool change_isv = false;
//
//    if (nodem_baton->name.compare(0, 2, "^[") == 0 || nodem_baton->name.compare(0, 2, "^|") == 0) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    int status;
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   call using SimpleAPI");
//
//    if (nodem_baton->name == "") {
//        ydb_buffer_t subs_array[1] = {8, 8, (char*) "v4wDebug"};
//
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//        status = freem_kill(1, subs_array);
//    } else {
//        char* var_name = (char*) nodem_baton->name.c_str();
//
//        ydb_buffer_t glvn;
//        glvn.len_alloc = glvn.len_used = strlen(var_name);
//        glvn.buf_addr = var_name;
//
//        ydb_buffer_t subs_array[YDB_MAX_SUBS];
//        unsigned int subs_size = nodem_baton->subs_array.size();
//
//        for (unsigned int i = 0; i < subs_size; i++) {
//            subs_array[i].len_alloc = subs_array[i].len_used = nodem_baton->subs_array[i].length();
//            subs_array[i].buf_addr = (char*) nodem_baton->subs_array[i].c_str();
//        }
//
//        int delete_type = (nodem_baton->node_only == 1) ? YDB_DEL_NODE : YDB_DEL_TREE;
//
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//        status = freem_kill(&glvn, subs_size, subs_array, delete_type);
//    }
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//    if (status != YDB_OK) ydb_zstatus(nodem_baton->error, ERR_LEN);
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//
//    /*
//    if (change_isv) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::kill exit");
//
//    return status;
//} // @end freem::kill function
//
///*
// * @function freem::order
// * @summary Return the next global or local node at the same level
// * @param {NodemBaton*} nodem_baton - struct containing the following members
// * @member {string} name - Global or local variable name
// * @member {vector<string>} subs_array - Subscripts
// * @member {char*} result - Data returned from YottaDB, via the SimpleAPI interface
// * @member {char*} error - Error message returned from YottaDB, via the SimpleAPI interface
// * @member {NodemState*} nodem_state - Per-thread state class containing the following members
// * @nested-member {debug_t} debug - Debug mode: OFF, LOW, MEDIUM, or HIGH; defaults to OFF
// * @returns {int} status - Return code; 0 is success, any other number is an error code
// */
//int order(nodem::NodemBaton* nodem_baton)
//{
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::order enter");
//
//    if (nodem_baton->nodem_state->debug > nodem::MEDIUM) {
//        nodem::debug_log(">>>    name: ", nodem_baton->name);
//
//        if (nodem_baton->subs_array.size()) {
//            for (unsigned int i = 0; i < nodem_baton->subs_array.size(); i++) {
//                nodem::debug_log(">>   subscripts[", i, "]: ", nodem_baton->subs_array[i]);
//            }
//        }
//    }
//
//    /*
//    string save_result;
//    bool change_isv = false;
//
//    if (nodem_baton->name.compare(0, 2, "^[") == 0 || nodem_baton->name.compare(0, 2, "^|") == 0) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    char* var_name = (char*) nodem_baton->name.c_str();
//
//    ydb_buffer_t glvn;
//    glvn.len_alloc = glvn.len_used = strlen(var_name);
//    glvn.buf_addr = var_name;
//
//    ydb_buffer_t subs_array[YDB_MAX_SUBS];
//    unsigned int subs_size = nodem_baton->subs_array.size();
//
//    for (unsigned int i = 0; i < subs_size; i++) {
//        subs_array[i].len_alloc = subs_array[i].len_used = nodem_baton->subs_array[i].length();
//        subs_array[i].buf_addr = (char*) nodem_baton->subs_array[i].c_str();
//    }
//
//    char order_data[YDB_MAX_STR];
//
//    ydb_buffer_t value;
//    value.len_alloc = YDB_MAX_STR;
//    value.len_used = 0;
//    value.buf_addr = (char*) &order_data;
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   call using SimpleAPI");
//
//    if (strncmp(glvn.buf_addr, "^", 1) != 0 && subs_size > 0) {
//        unsigned int  temp_value = 0;
//        unsigned int* ret_value = &temp_value;
//
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//        int status = freem_data(&glvn, 0, NULL, ret_value);
//
//        if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//
//        if (status == YDB_OK && *ret_value == 0) {
//            nodem_baton->result[0] = '\0';
//
//            if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::order exit");
//
//            return status;
//        }
//    }
//
//    int status;
//
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//    status = freem_order(&glvn, subs_size, subs_array, &value);
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//    if (status != YDB_OK) ydb_zstatus(nodem_baton->error, ERR_LEN);
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//
//    while (strncmp(value.buf_addr, "v4w", 3) == 0 && subs_size == 0) {
//        glvn.len_alloc = glvn.len_used = strlen(value.buf_addr);
//        glvn.buf_addr = value.buf_addr;
//
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//        status = freem_order(&glvn, subs_size, subs_array, &value);
//
//        if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//        if (status != YDB_OK) ydb_zstatus(nodem_baton->error, ERR_LEN);
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//        if (value.len_used == 0) break;
//    }
//
//    strncpy(nodem_baton->result, value.buf_addr, value.len_used);
//    nodem_baton->result[value.len_used] = '\0';
//
//    /*
//    if (change_isv) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::order exit");
//
//    return status;
//} // @end freem::order function
//
///*
// * @function freem::previous
// * @summary Return the previous global or local node at the same level
// * @param {NodemBaton*} nodem_baton - struct containing the following members
// * @member {string} name - Global or local variable name
// * @member {vector<string>} subs_array - Subscripts
// * @member {char*} result - Data returned from YottaDB, via the SimpleAPI interface
// * @member {char*} error - Error message returned from YottaDB, via the SimpleAPI interface
// * @member {NodemState*} nodem_state - Per-thread state class containing the following members
// * @nested-member {debug_t} debug - Debug mode: OFF, LOW, MEDIUM, or HIGH; defaults to OFF
// * @returns {int} status - Return code; 0 is success, any other number is an error code
// */
//int previous(nodem::NodemBaton* nodem_baton)
//{
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::previous enter");
//
//    if (nodem_baton->nodem_state->debug > nodem::MEDIUM) {
//        nodem::debug_log(">>>    name: ", nodem_baton->name);
//
//        if (nodem_baton->subs_array.size()) {
//            for (unsigned int i = 0; i < nodem_baton->subs_array.size(); i++) {
//                nodem::debug_log(">>   subscripts[", i, "]: ", nodem_baton->subs_array[i]);
//            }
//        }
//    }
//
//    /*
//    string save_result;
//    bool change_isv = false;
//
//    if (nodem_baton->name.compare(0, 2, "^[") == 0 || nodem_baton->name.compare(0, 2, "^|") == 0) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    char* var_name = (char*) nodem_baton->name.c_str();
//
//    ydb_buffer_t glvn;
//    glvn.len_alloc = glvn.len_used = strlen(var_name);
//    glvn.buf_addr = var_name;
//
//    ydb_buffer_t subs_array[YDB_MAX_SUBS];
//    unsigned int subs_size = nodem_baton->subs_array.size();
//
//    for (unsigned int i = 0; i < subs_size; i++) {
//        subs_array[i].len_alloc = subs_array[i].len_used = nodem_baton->subs_array[i].length();
//        subs_array[i].buf_addr = (char*) nodem_baton->subs_array[i].c_str();
//    }
//
//    char previous_data[YDB_MAX_STR];
//
//    ydb_buffer_t value;
//    value.len_alloc = YDB_MAX_STR;
//    value.len_used = 0;
//    value.buf_addr = (char*) &previous_data;
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   call using SimpleAPI");
//
//    if (strncmp(glvn.buf_addr, "^", 1) != 0 && subs_size > 0) {
//        unsigned int  temp_value = 0;
//        unsigned int* ret_value = &temp_value;
//
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//        int status = freem_data(&glvn, 0, NULL, ret_value);
//
//        if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//
//        if (status == YDB_OK && *ret_value == 0) {
//            nodem_baton->result[0] = '\0';
//
//            if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::previous exit");
//
//            return status;
//        }
//    }
//
//    int status;
//
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//    status = freem_order(&glvn, subs_size, subs_array, &value);
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//    if (status != YDB_OK) ydb_zstatus(nodem_baton->error, ERR_LEN);
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//
//    while (strncmp(value.buf_addr, "v4w", 3) == 0 && subs_size == 0) {
//        glvn.len_alloc = glvn.len_used = strlen(value.buf_addr);
//        glvn.buf_addr = value.buf_addr;
//
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//        status = freem_order(&glvn, subs_size, subs_array, &value);
//
//        if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//        if (status != YDB_OK) ydb_zstatus(nodem_baton->error, ERR_LEN);
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//        if (value.len_used == 0) break;
//    }
//
//    strncpy(nodem_baton->result, value.buf_addr, value.len_used);
//    nodem_baton->result[value.len_used] = '\0';
//
//    /*
//    if (change_isv) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::previous exit");
//
//    return status;
//} // @end freem::previous function
//
///*
// * @function freem::next_node
// * @summary Return the next global or local node, depth first
// * @param {NodemBaton*} nodem_baton - struct containing the following members
// * @member {string} name - Global or local variable name
// * @member {vector<string>} subs_array - Subscripts
// * @member {char*} result - Data returned from YottaDB, via the SimpleAPI interface
// * @member {char*} error - Error message returned from YottaDB, via the SimpleAPI interface
// * @member {NodemState*} nodem_state - Per-thread state class containing the following members
// * @nested-member {debug_t} debug - Debug mode: OFF, LOW, MEDIUM, or HIGH; defaults to OFF
// * @returns {int} status - Return code; 0 is success, any other number is an error code
// */
//int next_node(nodem::NodemBaton* nodem_baton)
//{
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::next_node enter");
//
//    if (nodem_baton->nodem_state->debug > nodem::MEDIUM) {
//        nodem::debug_log(">>>    name: ", nodem_baton->name);
//
//        if (nodem_baton->subs_array.size()) {
//            for (unsigned int i = 0; i < nodem_baton->subs_array.size(); i++) {
//                nodem::debug_log(">>   subscripts[", i, "]: ", nodem_baton->subs_array[i]);
//            }
//        }
//    }
//
//    /*
//    string save_result;
//    bool change_isv = false;
//
//    if (nodem_baton->name.compare(0, 2, "^[") == 0 || nodem_baton->name.compare(0, 2, "^|") == 0) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    char* var_name = (char*) nodem_baton->name.c_str();
//
//    ydb_buffer_t glvn;
//    glvn.len_alloc = glvn.len_used = strlen(var_name);
//    glvn.buf_addr = var_name;
//
//    ydb_buffer_t subs_array[YDB_MAX_SUBS];
//    unsigned int subs_size = nodem_baton->subs_array.size();
//
//    for (unsigned int i = 0; i < subs_size; i++) {
//        subs_array[i].len_alloc = subs_array[i].len_used = nodem_baton->subs_array[i].length();
//        subs_array[i].buf_addr = (char*) nodem_baton->subs_array[i].c_str();
//    }
//
//    int  subs_test = YDB_MAX_SUBS;
//    int* subs_used = &subs_test;
//
//    static char next_node_data[YDB_MAX_SUBS][YDB_MAX_STR];
//    static ydb_buffer_t ret_array[YDB_MAX_SUBS];
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   call using SimpleAPI");
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//    for (int i = 0; i < YDB_MAX_SUBS; i++) {
//        ret_array[i].len_alloc = YDB_MAX_STR;
//        ret_array[i].len_used = 0;
//        ret_array[i].buf_addr = (char*) &next_node_data[i][0];
//    }
//
//    int status = freem_query(&glvn, subs_size, subs_array, subs_used, ret_array);
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//
//    nodem_baton->subs_array.clear();
//
//    if (status != YDB_OK) {
//        ydb_zstatus(nodem_baton->error, ERR_LEN);
//
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//        if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::next_node exit");
//
//        return status;
//    }
//
//    if (*subs_used != YDB_NODE_END) {
//        for (int i = 0; i < *subs_used; i++) {
//            ret_array[i].buf_addr[ret_array[i].len_used] = '\0';
//            nodem_baton->subs_array.push_back(ret_array[i].buf_addr);
//        }
//    } else {
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//
//        nodem_baton->result[0] = '\0';
//        return YDB_NODE_END;
//    }
//
//    char ret_data[YDB_MAX_STR];
//
//    ydb_buffer_t value;
//    value.len_alloc = YDB_MAX_STR;
//    value.len_used = 0;
//    value.buf_addr = (char*) &ret_data;
//
//    status = freem_get(&glvn, *subs_used, ret_array, &value);
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//    if (status != YDB_OK) ydb_zstatus(nodem_baton->error, ERR_LEN);
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//
//    strncpy(nodem_baton->result, value.buf_addr, value.len_used);
//    nodem_baton->result[value.len_used] = '\0';
//
//    /*
//    if (change_isv) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::next_node exit");
//
//    return status;
//} // @end freem::next_node function
//
///*
// * @function freem::previous_node
// * @summary Return the previous global or local node, depth first
// * @param {NodemBaton*} nodem_baton - struct containing the following members
// * @member {string} name - Global or local variable name
// * @member {vector<string>} subs_array - Subscripts
// * @member {char*} result - Data returned from YottaDB, via the SimpleAPI interface
// * @member {char*} error - Error message returned from YottaDB, via the SimpleAPI interface
// * @member {NodemState*} nodem_state - Per-thread state class containing the following members
// * @nested-member {debug_t} debug - Debug mode: OFF, LOW, MEDIUM, or HIGH; defaults to OFF
// * @returns {int} status - Return code; 0 is success, any other number is an error code
// */
//int previous_node(nodem::NodemBaton* nodem_baton)
//{
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::previous_node enter");
//
//    if (nodem_baton->nodem_state->debug > nodem::MEDIUM) {
//        nodem::debug_log(">>>    name: ", nodem_baton->name);
//
//        if (nodem_baton->subs_array.size()) {
//            for (unsigned int i = 0; i < nodem_baton->subs_array.size(); i++) {
//                nodem::debug_log(">>   subscripts[", i, "]: ", nodem_baton->subs_array[i]);
//            }
//        }
//    }
//
//    /*
//    string save_result;
//    bool change_isv = false;
//
//    if (nodem_baton->name.compare(0, 2, "^[") == 0 || nodem_baton->name.compare(0, 2, "^|") == 0) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    char* var_name = (char*) nodem_baton->name.c_str();
//
//    ydb_buffer_t glvn;
//    glvn.len_alloc = glvn.len_used = strlen(var_name);
//    glvn.buf_addr = var_name;
//
//    ydb_buffer_t subs_array[YDB_MAX_SUBS];
//    unsigned int subs_size = nodem_baton->subs_array.size();
//
//    for (unsigned int i = 0; i < subs_size; i++) {
//        subs_array[i].len_alloc = subs_array[i].len_used = nodem_baton->subs_array[i].length();
//        subs_array[i].buf_addr = (char*) nodem_baton->subs_array[i].c_str();
//    }
//
//    int  subs_test = YDB_MAX_SUBS;
//    int* subs_used = &subs_test;
//
//    static char previous_node_data[YDB_MAX_SUBS][YDB_MAX_STR];
//    static ydb_buffer_t ret_array[YDB_MAX_SUBS];
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   call using SimpleAPI");
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//    for (int i = 0; i < YDB_MAX_SUBS; i++) {
//        ret_array[i].len_alloc = YDB_MAX_STR;
//        ret_array[i].len_used = 0;
//        ret_array[i].buf_addr = (char*) &previous_node_data[i][0];
//    }
//
//    int status = freem_query(&glvn, subs_size, subs_array, subs_used, ret_array);
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//
//    nodem_baton->subs_array.clear();
//
//    if (status != YDB_OK) {
//        ydb_zstatus(nodem_baton->error, ERR_LEN);
//
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//        if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::previous_node exit");
//
//        return status;
//    }
//
//    if (*subs_used != YDB_NODE_END) {
//        for (int i = 0; i < *subs_used; i++) {
//            ret_array[i].buf_addr[ret_array[i].len_used] = '\0';
//            nodem_baton->subs_array.push_back(ret_array[i].buf_addr);
//        }
//    } else {
//        *subs_used = 0;
//    }
//
//    char ret_data[YDB_MAX_STR];
//
//    ydb_buffer_t value;
//    value.len_alloc = YDB_MAX_STR;
//    value.len_used = 0;
//    value.buf_addr = (char*) &ret_data;
//
//    status = freem_get(&glvn, *subs_used, ret_array, &value);
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//    if (status != YDB_OK) ydb_zstatus(nodem_baton->error, ERR_LEN);
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//
//    if (subs_size == 0 || status == YDB_ERR_GVUNDEF || status == YDB_ERR_LVUNDEF) {
//        nodem_baton->result[0] = '\0';
//        return YDB_NODE_END;
//    } else {
//        strncpy(nodem_baton->result, value.buf_addr, value.len_used);
//        nodem_baton->result[value.len_used] = '\0';
//    }
//
//    /*
//    if (change_isv) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::previous_node exit");
//
//    return status;
//} // @end freem::previous_node function
//
///*
// * @function freem::lock
// * @summary Lock a global or local node, incrementally
// * @param {NodemBaton*} nodem_baton - struct containing the following members
// * @member {string} name - Global or local variable name
// * @member {vector<string>} subs_array - Subscripts
// * @member {ydb_double_t} option - The time to wait for the lock, or -1 to wait forever
// * @member {char*} result - Data returned from YottaDB, via the SimpleAPI interface
// * @member {char*} error - Error message returned from YottaDB, via the SimpleAPI interface
// * @member {NodemState*} nodem_state - Per-thread state class containing the following members
// * @nested-member {debug_t} debug - Debug mode: OFF, LOW, MEDIUM, or HIGH; defaults to OFF
// * @returns {int} status - Return code; 0 is success, any other number is an error code
// */
//int lock(nodem::NodemBaton* nodem_baton)
//{
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::lock enter");
//
//    if (nodem_baton->nodem_state->debug > nodem::MEDIUM) {
//        nodem::debug_log(">>>    name: ", nodem_baton->name);
//        nodem::debug_log(">>>    timeout: ", nodem_baton->option);
//
//        if (nodem_baton->subs_array.size()) {
//            for (unsigned int i = 0; i < nodem_baton->subs_array.size(); i++) {
//                nodem::debug_log(">>   subscripts[", i, "]: ", nodem_baton->subs_array[i]);
//            }
//        }
//    }
//
//    /*
//    string save_result;
//    bool change_isv = false;
//
//    if (nodem_baton->name.compare(0, 2, "^[") == 0 || nodem_baton->name.compare(0, 2, "^|") == 0) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    char* var_name = (char*) nodem_baton->name.c_str();
//
//    ydb_buffer_t glvn;
//    glvn.len_alloc = glvn.len_used = strlen(var_name);
//    glvn.buf_addr = var_name;
//
//    ydb_buffer_t subs_array[YDB_MAX_SUBS];
//    unsigned int subs_size = nodem_baton->subs_array.size();
//
//    for (unsigned int i = 0; i < subs_size; i++) {
//        subs_array[i].len_alloc = subs_array[i].len_used = nodem_baton->subs_array[i].length();
//        subs_array[i].buf_addr = (char*) nodem_baton->subs_array[i].c_str();
//    }
//
//    unsigned long long timeout;
//
//    if (nodem_baton->option == -1) {
//        timeout = YDB_MAX_TIME_NSEC;
//    } else {
//        timeout = nodem_baton->option * 1000000000;
//    }
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   call using SimpleAPI");
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//    int status = freem_lock(timeout, &glvn, subs_size, subs_array);
//
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//
//    if (status == YDB_OK) {
//        strncpy(nodem_baton->result, "1\0", 2);
//    } else if (status == YDB_LOCK_TIMEOUT) {
//        strncpy(nodem_baton->result, "0\0", 2);
//
//        status = YDB_OK;
//    } else {
//        ydb_zstatus(nodem_baton->error, ERR_LEN);
//    }
//
//    /*
//    if (change_isv) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::lock exit");
//
//    return status;
//} // @end freem::lock function
//
///*
// * @function freem::unlock
// * @summary Lock a global or local node, incrementally
// * @param {NodemBaton*} nodem_baton - struct containing the following members
// * @member {string} name - Global or local variable name
// * @member {vector<string>} subs_array - Subscripts
// * @member {char*} error - Error message returned from YottaDB, via the SimpleAPI interface
// * @member {NodemState*} nodem_state - Per-thread state class containing the following members
// * @nested-member {debug_t} debug - Debug mode: OFF, LOW, MEDIUM, or HIGH; defaults to OFF
// * @returns {int} status - Return code; 0 is success, any other number is an error code
// */
//int unlock(nodem::NodemBaton* nodem_baton)
//{
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::unlock enter");
//
//    if (nodem_baton->nodem_state->debug > nodem::MEDIUM) {
//        nodem::debug_log(">>>    name: ", nodem_baton->name);
//
//        if (nodem_baton->subs_array.size()) {
//            for (unsigned int i = 0; i < nodem_baton->subs_array.size(); i++) {
//                nodem::debug_log(">>   subscripts[", i, "]: ", nodem_baton->subs_array[i]);
//            }
//        }
//    }
//
//    /*
//    string save_result;
//    bool change_isv = false;
//
//    if (nodem_baton->name.compare(0, 2, "^[") == 0 || nodem_baton->name.compare(0, 2, "^|") == 0) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    int status;
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   call using SimpleAPI");
//
//    if (nodem_baton->name == "") {
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//        status = freem_unlock(0, 0);
//    } else {
//        char* var_name = (char*) nodem_baton->name.c_str();
//
//        ydb_buffer_t glvn;
//        glvn.len_alloc = glvn.len_used = strlen(var_name);
//        glvn.buf_addr = var_name;
//
//        ydb_buffer_t subs_array[YDB_MAX_SUBS];
//        unsigned int subs_size = nodem_baton->subs_array.size();
//
//        for (unsigned int i = 0; i < subs_size; i++) {
//            subs_array[i].len_alloc = subs_array[i].len_used = nodem_baton->subs_array[i].length();
//            subs_array[i].buf_addr = (char*) nodem_baton->subs_array[i].c_str();
//        }
//
//        if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_lock(&nodem::mutex_g);
//
//        status = freem_unlock(&glvn, subs_size, subs_array);
//    }
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   status: ", status);
//    if (status != YDB_OK) ydb_zstatus(nodem_baton->error, ERR_LEN);
//    if (nodem_baton->nodem_state->tp_level == 0) uv_mutex_unlock(&nodem::mutex_g);
//
//    /*
//    if (change_isv) {
//        int set_stat = extended_ref(nodem_baton, save_result, change_isv);
//
//        if (set_stat != YDB_OK) return set_stat;
//    }
//    */
//
//    if (nodem_baton->nodem_state->debug > nodem::LOW) nodem::debug_log(">>   freem::unlock exit");
//
//    return status;
//} // @end freem::unlock function

// ***End Public APIs***

} // @end freem namespace
